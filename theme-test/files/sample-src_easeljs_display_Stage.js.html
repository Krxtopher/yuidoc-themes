<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>sample-src/easeljs/display/Stage.js - CreateJS API</title>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="../assets/vendor/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <header class="main-header">
        <div class="content">
            <div class="project-title">
                
                    <img class="logo" src="https://d3oaxc4q5k2d6q.cloudfront.net/m/5c85e8398db4/img/language-avatars/actionscript_64.png" title="CreateJS API">
                
                
                    <h1 class="project-name">CreateJS API</h1> <span class="project-version">0.7.0</span>
                
                
                    <p class="description">A JavaScript API that brings Flash&#x27;s display list to HTML canvas.</p>
                
            </div>
            <ul class="jump-links">
                <li><a href="#index" class="index-jump-link">&uarr; index</a></li>
                <li><a href="#top" class="top-jump-link">&uarr; top</a></li>
            </ul>
        </div>
    </header>
    <div id="bd" class="main-body">

        <div id="docs-sidebar" class="sidebar apidocs">
            <div id="api-list">
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a class="type" href="../classes/AlphaMapFilter.html">AlphaMapFilter</a></li>
            
                <li><a class="type" href="../classes/AlphaMaskFilter.html">AlphaMaskFilter</a></li>
            
                <li><a class="type" href="../classes/Bitmap.html">Bitmap</a></li>
            
                <li><a class="type" href="../classes/BitmapAnimation.html">BitmapAnimation</a></li>
            
                <li><a class="type" href="../classes/BitmapText.html">BitmapText</a></li>
            
                <li><a class="type" href="../classes/BlurFilter.html">BlurFilter</a></li>
            
                <li><a class="type" href="../classes/ButtonHelper.html">ButtonHelper</a></li>
            
                <li><a class="type" href="../classes/ColorFilter.html">ColorFilter</a></li>
            
                <li><a class="type" href="../classes/ColorMatrix.html">ColorMatrix</a></li>
            
                <li><a class="type" href="../classes/ColorMatrixFilter.html">ColorMatrixFilter</a></li>
            
                <li><a class="type" href="../classes/Command.html">Command</a></li>
            
                <li><a class="type" href="../classes/Container.html">Container</a></li>
            
                <li><a class="type" href="../classes/DisplayObject.html">DisplayObject</a></li>
            
                <li><a class="type" href="../classes/DOMElement.html">DOMElement</a></li>
            
                <li><a class="type" href="../classes/EaselJS.html">EaselJS</a></li>
            
                <li><a class="type" href="../classes/Event.html">Event</a></li>
            
                <li><a class="type" href="../classes/EventDispatcher.html">EventDispatcher</a></li>
            
                <li><a class="type" href="../classes/Filter.html">Filter</a></li>
            
                <li><a class="type" href="../classes/Graphics.html">Graphics</a></li>
            
                <li><a class="type" href="../classes/Matrix2D.html">Matrix2D</a></li>
            
                <li><a class="type" href="../classes/MouseEvent.html">MouseEvent</a></li>
            
                <li><a class="type" href="../classes/MovieClip.html">MovieClip</a></li>
            
                <li><a class="type" href="../classes/MovieClipPlugin.html">MovieClipPlugin</a></li>
            
                <li><a class="type" href="../classes/Point.html">Point</a></li>
            
                <li><a class="type" href="../classes/Rectangle.html">Rectangle</a></li>
            
                <li><a class="type" href="../classes/Shadow.html">Shadow</a></li>
            
                <li><a class="type" href="../classes/Shape.html">Shape</a></li>
            
                <li><a class="type" href="../classes/Sprite.html">Sprite</a></li>
            
                <li><a class="type" href="../classes/SpriteSheet.html">SpriteSheet</a></li>
            
                <li><a class="type" href="../classes/SpriteSheetBuilder.html">SpriteSheetBuilder</a></li>
            
                <li><a class="type" href="../classes/SpriteSheetUtils.html">SpriteSheetUtils</a></li>
            
                <li><a class="type" href="../classes/Stage.html">Stage</a></li>
            
                <li><a class="type" href="../classes/Text.html">Text</a></li>
            
                <li><a class="type" href="../classes/Ticker.html">Ticker</a></li>
            
                <li><a class="type" href="../classes/Touch.html">Touch</a></li>
            
                <li><a class="type" href="../classes/UID.html">UID</a></li>
            
                <li><a class="type" href="../classes/Utility Methods.html">Utility Methods</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a class="module" href="../modules/CreateJS.html">CreateJS</a></li>
            
                <li><a class="module" href="../modules/EaselJS.html">EaselJS</a></li>
            
            </ul>
        </div>
    </div>
</div>

        </div>

        <div id="docs-main" class="apidocs">
            <div class="content container">
                <h1 class="file-heading">File: sample-src/easeljs/display/Stage.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
* Stage
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
*
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the &quot;Software&quot;), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/

/**
 * @module EaselJS
 */

// namespace:
this.createjs = this.createjs||{};

(function() {
	&quot;use strict&quot;;

/**
 * A stage is the root level {{#crossLink &quot;Container&quot;}}{{/crossLink}} for a display list. Each time its {{#crossLink &quot;Stage/tick&quot;}}{{/crossLink}}
 * method is called, it will render its display list to its target canvas.
 *
 * &lt;h4&gt;Example&lt;/h4&gt;
 * This example creates a stage, adds a child to it, then uses {{#crossLink &quot;Ticker&quot;}}{{/crossLink}} to update the child
 * and redraw the stage using {{#crossLink &quot;Stage/update&quot;}}{{/crossLink}}.
 *
 *      var stage = new createjs.Stage(&quot;canvasElementId&quot;);
 *      var image = new createjs.Bitmap(&quot;imagePath.png&quot;);
 *      stage.addChild(image);
 *      createjs.Ticker.addEventListener(&quot;tick&quot;, handleTick);
 *      function handleTick(event) {
 *          image.x += 10;
 *          stage.update();
 *      }
 *
 * @class Stage
 * @extends Container
 * @constructor
 * @param {HTMLCanvasElement | String | Object} canvas A canvas object that the Stage will render to, or the string id
 * of a canvas object in the current document.
 **/
var Stage = function(canvas) {
  this.initialize(canvas);
};
var p = Stage.prototype = new createjs.Container();

// static properties:
	/**
	 * @property _snapToPixelEnabled
	 * @protected
	 * @static
	 * @type {Boolean}
	 * @default false
	 * @deprecated Hardware acceleration in modern browsers makes this unnecessary.
	 **/
	Stage._snapToPixelEnabled = false; // snapToPixelEnabled is temporarily copied here during a draw to provide global access.

// events:

	/**
	 * Dispatched when the user moves the mouse over the canvas.
	 * See the {{#crossLink &quot;MouseEvent&quot;}}{{/crossLink}} class for a listing of event properties.
	 * @event stagemousemove
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the user presses their left mouse button on the canvas. See the {{#crossLink &quot;MouseEvent&quot;}}{{/crossLink}}
	 * class for a listing of event properties.
	 * @event stagemousedown
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the user the user releases the mouse button anywhere that the page can detect it (this varies slightly between browsers).
	 * See the {{#crossLink &quot;MouseEvent&quot;}}{{/crossLink}} class for a listing of event properties.
	 * @event stagemouseup
	 * @since 0.6.0
	 */

	/**
	 * Dispatched when the mouse moves from within the canvas area (mouseInBounds == true) to outside it (mouseInBounds == false).
	 * This is currently only dispatched for mouse input (not touch). See the {{#crossLink &quot;MouseEvent&quot;}}{{/crossLink}}
	 * class for a listing of event properties.
	 * @event mouseleave
	 * @since 0.7.0
	 */

	/**
	 * Dispatched when the mouse moves into the canvas area (mouseInBounds == false) from outside it (mouseInBounds == true).
	 * This is currently only dispatched for mouse input (not touch). See the {{#crossLink &quot;MouseEvent&quot;}}{{/crossLink}}
	 * class for a listing of event properties.
	 * @event mouseenter
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately before the tick event is propagated through the display list. Does not fire if
	 * tickOnUpdate is false.
	 * @event tickstart
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately after the tick event is propagated through the display list. Does not fire if
	 * tickOnUpdate is false. Precedes the &quot;drawstart&quot; event.
	 * @event tickend
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately before the canvas is cleared and the display list is drawn to it.
	 * @event drawstart
	 * @since 0.7.0
	 */
	 
	/**
	 * Dispatched each update immediately after the display list is drawn to the canvas and the canvas context is restored.
	 * @event drawend
	 * @since 0.7.0
	 */

// public properties:
	/**
	 * Indicates whether the stage should automatically clear the canvas before each render. You can set this to &lt;code&gt;false&lt;/code&gt;
	 * to manually control clearing (for generative art, or when pointing multiple stages at the same canvas for
	 * example).
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *
	 *      var stage = new createjs.Stage(&quot;canvasId&quot;);
	 *      stage.autoClear = false;
	 *
	 * @property autoClear
	 * @type Boolean
	 * @default true
	 **/
	p.autoClear = true;

	/**
	 * The canvas the stage will render to. Multiple stages can share a single canvas, but you must disable autoClear for all but the
	 * first stage that will be ticked (or they will clear each other&#x27;s render).
	 *
	 * When changing the canvas property you must disable the events on the old canvas, and enable events on the
	 * new canvas or mouse events will not work as expected. For example:
	 *
	 *      myStage.enableDOMEvents(false);
	 *      myStage.canvas = anotherCanvas;
	 *      myStage.enableDOMEvents(true);
	 *
	 * @property canvas
	 * @type HTMLCanvasElement | Object
	 **/
	p.canvas = null;

	/**
	 * The current mouse X position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
	 * position over the canvas, and mouseInBounds will be set to false.
	 * @property mouseX
	 * @type Number
	 * @readonly
	 **/
	p.mouseX = 0;

	/**
	 * The current mouse Y position on the canvas. If the mouse leaves the canvas, this will indicate the most recent
	 * position over the canvas, and mouseInBounds will be set to false.
	 * @property mouseY
	 * @type Number
	 * @readonly
	 **/
	p.mouseY = 0;

	// TODO: deprecated.
	/**
	 * REMOVED. Use {{#crossLink &quot;EventDispatcher/addEventListener&quot;}}{{/crossLink}} and the &quot;{{#crossLink &quot;Stage/stagemousemove:event&quot;}}{{/crossLink}}
	 * event.
	 * @property onMouseMove
	 * @type Function
	 * @deprecated Use addEventListener and the &quot;stagemousemove&quot; event.
	 */
	/**
	 * REMOVED. Use {{#crossLink &quot;EventDispatcher/addEventListener&quot;}}{{/crossLink}} and the {{#crossLink &quot;Stage/stagemouseup:event&quot;}}{{/crossLink}}
	 * event.
	 * @property onMouseUp
	 * @type Function
	 * @deprecated Use addEventListener and the &quot;stagemouseup&quot; event.
	 */
	/**
	 * REMOVED. Use {{#crossLink &quot;EventDispatcher/addEventListener&quot;}}{{/crossLink}} and the {{#crossLink &quot;Stage/stagemousedown:event&quot;}}{{/crossLink}}
	 * event.
	 * @property onMouseDown
	 * @type Function
	 * @deprecated Use addEventListener and the &quot;stagemousedown&quot; event.
	 */

	// TODO: deprecated.
	/**
	 * Indicates whether this stage should use the {{#crossLink &quot;DisplayObject/snapToPixel&quot;}}{{/crossLink}} property of
	 * display objects when rendering them.
	 * @property snapToPixelEnabled
	 * @type Boolean
	 * @default false
	 * @deprecated Hardware acceleration makes this not beneficial
	 **/
	p.snapToPixelEnabled = false;

	/**
	 * Indicates whether the mouse is currently within the bounds of the canvas.
	 * @property mouseInBounds
	 * @type Boolean
	 * @default false
	 **/
	p.mouseInBounds = false;

	/**
	 * If true, tick callbacks will be called on all display objects on the stage prior to rendering to the canvas.
	 * @property tickOnUpdate
	 * @type Boolean
	 * @default true
	 **/
	p.tickOnUpdate = true;

	/**
	 * If true, mouse move events will continue to be called when the mouse leaves the target canvas. See
	 * {{#crossLink &quot;Stage/mouseInBounds:property&quot;}}{{/crossLink}}, and {{#crossLink &quot;MouseEvent&quot;}}{{/crossLink}}
	 * x/y/rawX/rawY.
	 * @property mouseMoveOutside
	 * @type Boolean
	 * @default false
	 **/
	p.mouseMoveOutside = false;
	
	// TODO: confirm naming and inclusion.
	/**
	 * NOTE: this name is not final. Feedback is appreciated.
	 *
	 * The stage assigned to this property will have mouse interactions relayed to it after this stage handles them.
	 * This can be useful in cases where you have multiple canvases layered on top of one another and want your mouse
	 * events to pass through. For example, this would relay mouse events from topStage to bottomStage:
	 *
	 *      topStage.nextStage = bottomStage;
	 *
	 * Note that each stage handles the interactions independently. As such, you could have a click register on an
	 * object in the top stage, and another click register in the bottom stage. Consider using a single canvas with
	 * cached {{#crossLink &quot;Container&quot;}}{{/crossLink}} instances instead of multiple canvases.
	 *
	 * MouseOver, MouseOut, RollOver, and RollOut interactions will not be passed through. They must be enabled using
	 * {{#crossLink &quot;Stage/enableMouseOver&quot;}}{{/crossLink}} for each stage individually.
	 * 
	 * In most instances, you will also want to disable DOM events for the next stage to avoid duplicate interactions.
	 * myNextStage.enableDOMEvents(false);
	 * 
	 * @property nextStage
	 * @type Stage
	 **/
	p.nextStage = null;

	/**
	 * The hitArea property is not supported for Stage.
	 * @property hitArea
	 * @type {DisplayObject}
	 * @default null
	 */

// private properties:

	/**
	 * Holds objects with data for each active pointer id. Each object has the following properties:
	 * x, y, event, target, overTarget, overX, overY, inBounds, posEvtObj (native event that last updated position)
	 * @property _pointerData
	 * @type {Object}
	 * @private
	 */
	p._pointerData = null;

	/**
	 * Number of active pointers.
	 * @property _pointerCount
	 * @type {Object}
	 * @private
	 */
	p._pointerCount = 0;

	/**
	 * The ID of the primary pointer.
	 * @property _primaryPointerID
	 * @type {Object}
	 * @private
	 */
	p._primaryPointerID = null;

	/**
	 * @property _mouseOverIntervalID
	 * @protected
	 * @type Number
	 **/
	p._mouseOverIntervalID = null;

// constructor:
	/**
	 * @property DisplayObject_initialize
	 * @type Function
	 * @private
	 **/
	p.Container_initialize = p.initialize;

	/**
	 * Initialization method.
	 * @method initialize
	 * @param {HTMLCanvasElement | String | Object} canvas A canvas object, or the string id of a canvas object in the current document.
	 * @protected
	 **/
	p.initialize = function(canvas) {
		this.Container_initialize();
		this.canvas = (typeof canvas == &quot;string&quot;) ? document.getElementById(canvas) : canvas;
		this._pointerData = {};
		this.enableDOMEvents(true);
	};

// public methods:

	/**
	 * Each time the update method is called, the stage will tick all descendants (see: {{#crossLink &quot;DisplayObject/tick&quot;}}{{/crossLink}})
	 * and then render the display list to the canvas. Any parameters passed to &#x60;update()&#x60; will be passed on to any
	 * {{#crossLink &quot;DisplayObject/tick:event&quot;}}{{/crossLink}} event handlers.
	 *
	 * Some time-based features in EaselJS (for example {{#crossLink &quot;Sprite/framerate&quot;}}{{/crossLink}} require that
	 * a tick event object (or equivalent) be passed as the first parameter to update(). For example:
	 *
	 *      Ticker.addEventListener(&quot;tick&quot;, handleTick);
	 * 	    function handleTick(evtObj) {
	 * 	     	// do some work here, then update the stage, passing through the event object:
	 * 	    	myStage.update(evtObj);
	 * 	    }
	 *
	 * @method update
	 * @param {*} [params]* Params to include when ticking descendants. The first param should usually be a tick event.
	 **/
	p.update = function(params) {
		if (!this.canvas) { return; }
		if (this.tickOnUpdate) {
			this.dispatchEvent(&quot;tickstart&quot;);  // TODO: make cancellable?
			this.tickEnabled&amp;&amp;this._tick((arguments.length ? arguments : null));
			this.dispatchEvent(&quot;tickend&quot;);
		}
		this.dispatchEvent(&quot;drawstart&quot;); // TODO: make cancellable?
		Stage._snapToPixelEnabled = this.snapToPixelEnabled;
		if (this.autoClear) { this.clear(); }
		var ctx = this.canvas.getContext(&quot;2d&quot;);
		ctx.save();
		this.updateContext(ctx);
		this.draw(ctx, false);
		ctx.restore();
		this.dispatchEvent(&quot;drawend&quot;);
	};

	/**
	 * Default event handler that calls the Stage {{#crossLink &quot;Stage/update&quot;}}{{/crossLink}} method when a {{#crossLink &quot;DisplayObject/tick:event&quot;}}{{/crossLink}}
	 * event is received. This allows you to register a Stage instance as a event listener on {{#crossLink &quot;Ticker&quot;}}{{/crossLink}}
	 * directly, using:
	 *
	 *      Ticker.addEventListener(&quot;tick&quot;, myStage&quot;);
	 *
	 * Note that if you subscribe to ticks using this pattern, then the tick event object will be passed through to
	 * display object tick handlers, instead of &lt;code&gt;delta&lt;/code&gt; and &lt;code&gt;paused&lt;/code&gt; parameters.
	 * @property handleEvent
	 * @type Function
	 **/
	p.handleEvent = function(evt) {
		if (evt.type == &quot;tick&quot;) { this.update(evt); }
	};

	/**
	 * Clears the target canvas. Useful if {{#crossLink &quot;Stage/autoClear:property&quot;}}{{/crossLink}} is set to &#x60;false&#x60;.
	 * @method clear
	 **/
	p.clear = function() {
		if (!this.canvas) { return; }
		var ctx = this.canvas.getContext(&quot;2d&quot;);
		ctx.setTransform(1, 0, 0, 1, 0, 0);
		ctx.clearRect(0, 0, this.canvas.width+1, this.canvas.height+1);
	};

	/**
	 * Returns a data url that contains a Base64-encoded image of the contents of the stage. The returned data url can
	 * be specified as the src value of an image element.
	 * @method toDataURL
	 * @param {String} backgroundColor The background color to be used for the generated image. The value can be any value HTML color
	 * value, including HEX colors, rgb and rgba. The default value is a transparent background.
	 * @param {String} mimeType The MIME type of the image format to be create. The default is &quot;image/png&quot;. If an unknown MIME type
	 * is passed in, or if the browser does not support the specified MIME type, the default value will be used.
	 * @return {String} a Base64 encoded image.
	 **/
	p.toDataURL = function(backgroundColor, mimeType) {
		if(!mimeType) {
			mimeType = &quot;image/png&quot;;
		}

		var ctx = this.canvas.getContext(&#x27;2d&#x27;);
		var w = this.canvas.width;
		var h = this.canvas.height;

		var data;

		if(backgroundColor) {

			//get the current ImageData for the canvas.
			data = ctx.getImageData(0, 0, w, h);

			//store the current globalCompositeOperation
			var compositeOperation = ctx.globalCompositeOperation;

			//set to draw behind current content
			ctx.globalCompositeOperation = &quot;destination-over&quot;;

			//set background color
			ctx.fillStyle = backgroundColor;

			//draw background on entire canvas
			ctx.fillRect(0, 0, w, h);
		}

		//get the image data from the canvas
		var dataURL = this.canvas.toDataURL(mimeType);

		if(backgroundColor) {
			//clear the canvas
			ctx.clearRect (0, 0, w+1, h+1);

			//restore it with original settings
			ctx.putImageData(data, 0, 0);

			//reset the globalCompositeOperation to what it was
			ctx.globalCompositeOperation = compositeOperation;
		}

		return dataURL;
	};

	/**
	 * Enables or disables (by passing a frequency of 0) mouse over ({{#crossLink &quot;DisplayObject/mouseover:event&quot;}}{{/crossLink}}
	 * and {{#crossLink &quot;DisplayObject/mouseout:event&quot;}}{{/crossLink}}) and roll over events ({{#crossLink &quot;DisplayObject/rollover:event&quot;}}{{/crossLink}}
	 * and {{#crossLink &quot;DisplayObject/rollout:event&quot;}}{{/crossLink}}) for this stage&#x27;s display list. These events can
	 * be expensive to generate, so they are disabled by default. The frequency of the events can be controlled
	 * independently of mouse move events via the optional &#x60;frequency&#x60; parameter.
	 *
	 * &lt;h4&gt;Example&lt;/h4&gt;
	 *      var stage = new createjs.Stage(&quot;canvasId&quot;);
	 *      stage.enableMouseOver(10); // 10 updates per second
	 *
	 * @method enableMouseOver
	 * @param {Number} [frequency=20] Optional param specifying the maximum number of times per second to broadcast
	 * mouse over/out events. Set to 0 to disable mouse over events completely. Maximum is 50. A lower frequency is less
	 * responsive, but uses less CPU.
	 **/
	p.enableMouseOver = function(frequency) {
		if (this._mouseOverIntervalID) {
			clearInterval(this._mouseOverIntervalID);
			this._mouseOverIntervalID = null;
			if (frequency == 0) {
				this._testMouseOver(true);
			}
		}
		if (frequency == null) { frequency = 20; }
		else if (frequency &lt;= 0) { return; }
		var o = this;
		this._mouseOverIntervalID = setInterval(function(){ o._testMouseOver(); }, 1000/Math.min(50,frequency));
	};

	/**
	 * Enables or disables the event listeners that stage adds to DOM elements (window, document and canvas). It is good
	 * practice to disable events when disposing of a Stage instance, otherwise the stage will continue to receive
	 * events from the page.
	 *
	 * When changing the canvas property you must disable the events on the old canvas, and enable events on the
	 * new canvas or mouse events will not work as expected. For example:
	 *
	 *      myStage.enableDOMEvents(false);
	 *      myStage.canvas = anotherCanvas;
	 *      myStage.enableDOMEvents(true);
	 *
	 * @method enableDOMEvents
	 * @param {Boolean} [enable=true] Indicates whether to enable or disable the events. Default is true.
	 **/
	p.enableDOMEvents = function(enable) {
		if (enable == null) { enable = true; }
		var n, o, ls = this._eventListeners;
		if (!enable &amp;&amp; ls) {
			for (n in ls) {
				o = ls[n];
				o.t.removeEventListener(n, o.f, false);
			}
			this._eventListeners = null;
		} else if (enable &amp;&amp; !ls &amp;&amp; this.canvas) {
			var t = window.addEventListener ? window : document;
			var _this = this;
			ls = this._eventListeners = {};
			ls[&quot;mouseup&quot;] = {t:t, f:function(e) { _this._handleMouseUp(e)} };
			ls[&quot;mousemove&quot;] = {t:t, f:function(e) { _this._handleMouseMove(e)} };
			ls[&quot;dblclick&quot;] = {t:t, f:function(e) { _this._handleDoubleClick(e)} };
			ls[&quot;mousedown&quot;] = {t:this.canvas, f:function(e) { _this._handleMouseDown(e)} };

			for (n in ls) {
				o = ls[n];
				o.t.addEventListener(n, o.f, false);
			}
		}
	};

	/**
	 * Returns a clone of this Stage.
	 * @method clone
	 * @return {Stage} A clone of the current Container instance.
	 **/
	p.clone = function() {
		var o = new Stage(null);
		this.cloneProps(o);
		return o;
	};

	/**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **/
	p.toString = function() {
		return &quot;[Stage (name=&quot;+  this.name +&quot;)]&quot;;
	};

	// private methods:

	/**
	 * @method _getElementRect
	 * @protected
	 * @param {HTMLElement} e
	 **/
	p._getElementRect = function(e) {
		var bounds;
		try { bounds = e.getBoundingClientRect(); } // this can fail on disconnected DOM elements in IE9
		catch (err) { bounds = {top: e.offsetTop, left: e.offsetLeft, width:e.offsetWidth, height:e.offsetHeight}; }

		var offX = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0);
		var offY = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop  || document.body.clientTop  || 0);

		var styles = window.getComputedStyle ? getComputedStyle(e) : e.currentStyle; // IE &lt;9 compatibility.
		var padL = parseInt(styles.paddingLeft)+parseInt(styles.borderLeftWidth);
		var padT = parseInt(styles.paddingTop)+parseInt(styles.borderTopWidth);
		var padR = parseInt(styles.paddingRight)+parseInt(styles.borderRightWidth);
		var padB = parseInt(styles.paddingBottom)+parseInt(styles.borderBottomWidth);

		// note: in some browsers bounds properties are read only.
		return {
			left: bounds.left+offX+padL,
			right: bounds.right+offX-padR,
			top: bounds.top+offY+padT,
			bottom: bounds.bottom+offY-padB
		}
	};

	/**
	 * @method _getPointerData
	 * @protected
	 * @param {Number} id
	 **/
	p._getPointerData = function(id) {
		var data = this._pointerData[id];
		if (!data) {
			data = this._pointerData[id] = {x:0,y:0};
			// if it&#x27;s the first new touch, then make it the primary pointer id:
			if (this._primaryPointerID == null) { this._primaryPointerID = id; }
		}
		return data;
	};

	/**
	 * @method _handleMouseMove
	 * @protected
	 * @param {MouseEvent} e
	 **/
	p._handleMouseMove = function(e) {
		if(!e){ e = window.event; }
		this._handlePointerMove(-1, e, e.pageX, e.pageY);
	};

	/**
	 * @method _handlePointerMove
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Number} pageX
	 * @param {Number} pageY
	 **/
	p._handlePointerMove = function(id, e, pageX, pageY) {
		if (!this.canvas) { return; }
		var o = this._getPointerData(id);

		var inBounds = o.inBounds;
		this._updatePointerPosition(id, e, pageX, pageY);
		if (!inBounds &amp;&amp; !o.inBounds &amp;&amp; !this.mouseMoveOutside) { return; }
		if (id == -1 &amp;&amp; o.inBounds == !inBounds) {
			this._dispatchMouseEvent(this, (inBounds ? &quot;mouseleave&quot; : &quot;mouseenter&quot;), false, id, o, e);
		}
		
		this._dispatchMouseEvent(this, &quot;stagemousemove&quot;, false, id, o, e);
		this._dispatchMouseEvent(o.target, &quot;pressmove&quot;, true, id, o, e);

		// TODO: deprecated:
		var oEvent = o.event;
		if (oEvent &amp;&amp; oEvent.hasEventListener(&quot;mousemove&quot;)) {
			// this doesn&#x27;t use _dispatchMouseEvent because it requires re-targeting.
			oEvent.dispatchEvent(new createjs.MouseEvent(&quot;mousemove&quot;, false, false, o.x, o.y, e, id, (id == this._primaryPointerID), o.rawX, o.rawY), oTarget);
		}

		this.nextStage&amp;&amp;this.nextStage._handlePointerMove(id, e, pageX, pageY);
	};

	/**
	 * @method _updatePointerPosition
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Number} pageX
	 * @param {Number} pageY
	 **/
	p._updatePointerPosition = function(id, e, pageX, pageY) {
		var rect = this._getElementRect(this.canvas);
		pageX -= rect.left;
		pageY -= rect.top;

		var w = this.canvas.width;
		var h = this.canvas.height;
		pageX /= (rect.right-rect.left)/w;
		pageY /= (rect.bottom-rect.top)/h;
		var o = this._getPointerData(id);
		if (o.inBounds = (pageX &gt;= 0 &amp;&amp; pageY &gt;= 0 &amp;&amp; pageX &lt;= w-1 &amp;&amp; pageY &lt;= h-1)) {
			o.x = pageX;
			o.y = pageY;
		} else if (this.mouseMoveOutside) {
			o.x = pageX &lt; 0 ? 0 : (pageX &gt; w-1 ? w-1 : pageX);
			o.y = pageY &lt; 0 ? 0 : (pageY &gt; h-1 ? h-1 : pageY);
		}

		o.posEvtObj = e;
		o.rawX = pageX;
		o.rawY = pageY;

		if (id == this._primaryPointerID) {
			this.mouseX = o.x;
			this.mouseY = o.y;
			this.mouseInBounds = o.inBounds;
		}
	};

	/**
	 * @method _handleMouseUp
	 * @protected
	 * @param {MouseEvent} e
	 **/
	p._handleMouseUp = function(e) {
		this._handlePointerUp(-1, e, false);
	};

	/**
	 * @method _handlePointerUp
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Boolean} clear
	 **/
	p._handlePointerUp = function(id, e, clear) {
		var o = this._getPointerData(id);

		this._dispatchMouseEvent(this, &quot;stagemouseup&quot;, false, id, o, e);

		var oTarget = o.target;
		if (oTarget) {
			if (this._getObjectsUnderPoint(o.x, o.y, null, true) == oTarget) {
				this._dispatchMouseEvent(oTarget, &quot;click&quot;, true, id, o, e);
			}
			this._dispatchMouseEvent(oTarget, &quot;pressup&quot;, true, id, o, e);
		}

		// TODO: deprecated:
		var oEvent = o.event;
		if (oEvent &amp;&amp; oEvent.hasEventListener(&quot;mouseup&quot;)) {
			// this doesn&#x27;t use _dispatchMouseEvent because it requires re-targeting.
			oEvent.dispatchEvent(new createjs.MouseEvent(&quot;mouseup&quot;, false, false, o.x, o.y, e, id, (id==this._primaryPointerID), o.rawX, o.rawY), oTarget);
		}

		if (clear) {
			if (id==this._primaryPointerID) { this._primaryPointerID = null; }
			delete(this._pointerData[id]);
		} else { o.event = o.target = null; }

		this.nextStage&amp;&amp;this.nextStage._handlePointerUp(id, e, clear);
	};

	/**
	 * @method _handleMouseDown
	 * @protected
	 * @param {MouseEvent} e
	 **/
	p._handleMouseDown = function(e) {
		this._handlePointerDown(-1, e, e.pageX, e.pageY);
	};

	/**
	 * @method _handlePointerDown
	 * @protected
	 * @param {Number} id
	 * @param {Event} e
	 * @param {Number} pageX
	 * @param {Number} pageY
	 **/
	p._handlePointerDown = function(id, e, pageX, pageY) {
		if (pageY != null) { this._updatePointerPosition(id, e, pageX, pageY); }
		var o = this._getPointerData(id);

		this._dispatchMouseEvent(this, &quot;stagemousedown&quot;, false, id, o, e);

		o.target = this._getObjectsUnderPoint(o.x, o.y, null, true);
		this._dispatchMouseEvent(o.target, &quot;mousedown&quot;, true, id, o, e);

		this.nextStage&amp;&amp;this.nextStage._handlePointerDown(id, e, pageX, pageY);
	};

	/**
	 * @method _testMouseOver
	 * @param {Boolean} clear If true, clears the mouseover / rollover (ie. no target)
	 * @protected
	 **/
	p._testMouseOver = function(clear) {
		// only update if the mouse position has changed. This provides a lot of optimization, but has some trade-offs.
		if (this._primaryPointerID != -1 || (!clear &amp;&amp; this.mouseX == this._mouseOverX &amp;&amp; this.mouseY == this._mouseOverY &amp;&amp; this.mouseInBounds)) { return; }
		var o = this._getPointerData(-1);
		var e = o.posEvtObj;
		var target, common = -1, cursor=&quot;&quot;, t, i, l;
		
		if (clear || this.mouseInBounds &amp;&amp; e &amp;&amp; e.target == this.canvas) {
			target = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, true);
			this._mouseOverX = this.mouseX;
			this._mouseOverY = this.mouseY;
		}

		var oldList = this._mouseOverTarget||[];
		var oldTarget = oldList[oldList.length-1];
		var list = this._mouseOverTarget = [];

		// generate ancestor list and check for cursor:
		t = target;
		while (t) {
			list.unshift(t);
			if (t.cursor != null) { cursor = t.cursor; }
			t = t.parent;
		}
		this.canvas.style.cursor = cursor;

		// find common ancestor:
		for (i=0,l=list.length; i&lt;l; i++) {
			if (list[i] != oldList[i]) { break; }
			common = i;
		}

		if (oldTarget != target) {
			this._dispatchMouseEvent(oldTarget, &quot;mouseout&quot;, true, -1, o, e);
		}

		for (i=oldList.length-1; i&gt;common; i--) {
			this._dispatchMouseEvent(oldList[i], &quot;rollout&quot;, false, -1, o, e);
		}

		for (i=list.length-1; i&gt;common; i--) {
			this._dispatchMouseEvent(list[i], &quot;rollover&quot;, false, -1, o, e);
		}

		if (oldTarget != target) {
			this._dispatchMouseEvent(target, &quot;mouseover&quot;, true, -1, o, e);
		}

	};

	/**
	 * @method _handleDoubleClick
	 * @protected
	 * @param {MouseEvent} e
	 **/
	p._handleDoubleClick = function(e) {
		var o = this._getPointerData(-1);
		var target = this._getObjectsUnderPoint(o.x, o.y, null, true);
		this._dispatchMouseEvent(target, &quot;dblclick&quot;, true, -1, o, e);

		this.nextStage&amp;&amp;this.nextStage._handleDoubleClick(e);
	};

	/**
	 * @method _dispatchMouseEvent
	 * @protected
	 * @param {DisplayObject} target
	 * @param {String} type
	 * @param {Boolean} bubbles
	 * @param {Number} pointerId
	 * @param {Object} o
	 * @param {MouseEvent} [nativeEvent]
	 **/
	p._dispatchMouseEvent = function(target, type, bubbles, pointerId, o, nativeEvent) {
		// TODO: might be worth either reusing MouseEvent instances, or adding a willTrigger method to avoid GC.
		if (!target || (!bubbles &amp;&amp; !target.hasEventListener(type))) { return; }
		/*
		// TODO: account for stage transformations:
		this._mtx = this.getConcatenatedMatrix(this._mtx).invert();
		var pt = this._mtx.transformPoint(o.x, o.y);
		var evt = new createjs.MouseEvent(type, bubbles, false, pt.x, pt.y, nativeEvent, pointerId, pointerId==this._primaryPointerID, o.rawX, o.rawY);
		*/
		var evt = new createjs.MouseEvent(type, bubbles, false, o.x, o.y, nativeEvent, pointerId, pointerId==this._primaryPointerID, o.rawX, o.rawY);
		target.dispatchEvent(evt);
	};

createjs.Stage = Stage;
}());

    </pre>
</div>

            </div>
        </div>

    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/vendor/jquery.min.js"></script>
<script src="../assets/js/jquery-ks-scroll-styles.js"></script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
